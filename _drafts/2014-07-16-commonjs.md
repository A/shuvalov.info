---

layout: post
title: "Как работает CommonJS"
description: ""
keywords: [""]

---


### И сразу… Дисклеймер

_На самом деле, все несколько сложнее, чем здесь написано. Ниже, я хочу, в общих
чертах рассказать о принципах работы CommonJS, и об использовании этой модульной
системы в браузере, как более простой альтернативе AMD._


### Введение

[CommonJS][1] — это рабочая группа энтузиастов, которая проектирует,
прототипирует и стандартизирует различные JavaScript API. Благодаря труду
этих ребят появился одноименный стандарт модульной системы, о котором я и
буду рассказывать дальше.

Сейчас CommonJS используется преимущественно в NodeJS — серверном JavaScript.
Но с каждым днем он все ближе подбирается к браузерам. Тогда как модульность —
это и есть один из главных залогов гибкости, CommonJS с помощью простого
интерфейса позволяет достаточно легко создавать устойчивые к изменениям системы,
состоящие из готовых к переиспользованию компонентов. На сегодняшний день,
существует достаточно большое количество утилит, позволяющех использовать
CommonJS-модули в браузере. Первыми в голову приходят [browserify][2], [clinch][3] и
[Component][4].

«Чистый» CommonJS, в сравнивнении с существующими решениями, похож на AMD, но,
в отличии от последнего, менее компромисный. и более простой. Дизайн, основанный
на простоте позволяет за меньшее количество усилий получить практически
аналогичные возможности.

В отличие от Bower, CommonJS позволяет подключать зависимости в переменные,
контролируя глобальный скоп.


## Как работает CommonJS

Объясню устройство CommonJS Не слишком углубляясь в подробности:

Содержимое каждого из модулей оборачивается в замыкания, в которые через
аргументы передаются ссылки на служебные методы и объекты:

```JS
function (require, module) {
  // content 
}
```

-  `require`— этот метод позволяет подключать другие модули по имени или
   по относительному пути к файлу. Пример: `require('./my-awesome-module.js')`,
-  `module.exports` — сюда сохраняется то, что должен вернуть `require` при
   подключении этого модуля. У `module.exports` есть короткий синоним — `exports`.
-  В NodeJS через аргументы замыкания передаются еще и глобальные объекты
   `process`, `global`.


Полученные в результате замыкания сохраняются в специальный словарь, где ключ
равен абсолютному пути к файлу модуля. Таким образом, `require` всегда возвращает
ссылку на единственное замыкание, в котором хранится код модуля вне зависимости
от способа подключения. 

Вот, в общем-то и все устройство.  

### Пример модуля

```
'use strict';

var $ = require('jquery');
var counter = 0;

exports.add = function (count) {
  counter += count || 1;
};

exports.get = function () {
  return counter;
}

exports.reset = function () {
  counter = 0;
}
```


Этот пример достаточно наглядно показывает, что в сущности CommonJS-модуль — это
замыкание.


## Сборка

Для сборки с помощью `browserify` достаточно набрать в консоли:

```
browserify index.js > bundle.js
```

Browseryfy соберет все используемые модули в один файл, который можно будет
подключить к браузеру как обычный скрипт. Кроме этого, browserify позаботится
о замене некоторых нативных nodejs-модулей, таких как `util` для использования
в браузере.


## Поддержка

Часто так случается, что определенный модуль не поддерживает CommonJS. В большинстве
случаев добавить поддержку достаточно тривиально. Вот пример обертки над jQuery-плагином,
позволяющей использовать его с CommonJS и AMD:

```
(function (factory) {
  "use strict";
  if (typeof define === 'function' && define.amd) {
    // using AMD
    define(['jquery'], factory);
  //
  } else if (typeof exports !== 'undefined') {
    using CommonJS
    module.exports = factory;
  } else {
    // no AMD/CommonJS; invoke directly
    factory( (typeof(jQuery) != 'undefined') ? jQuery : window.Zepto );
  }
})(function($) {
  "use strict";
    // plugin code
  });
```

Я верю, что разработчики модулей в скором времени начнут уделять больше
внимания поддержке CommonJS и публикации своих проектов в NPM или Component,
ну и мы придем к удобной и функциональной модульной системе, и менеджеру
пакетов.

В конце хочется отметить, что с npm в плане управления клиентскими зависимостями
нужно держать ухо в остро — принцип вложенных зависимостей не приемлем для
браузеров, и, не уделяя этому внимания, вы рискуете подключить 4 версии jQuery,
11 — Backbone и 9 — Underscore. В этом отношении Component, использующий
плоские зависимости, будет гораздо безопаснее, но я, честно говоря, не успел его
еще достаточно опробовать.


[1]: http://www.commonjs.org/
[2]: http://browserify.org/
[3]: https://github.com/Meettya/clinch
[4]: http://component.io/
