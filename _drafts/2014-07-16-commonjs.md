---

layout: post
title: "Как работает CommonJS"
description: ""
keywords: [""]

---


### И сразу… Дисклеймер

_На самом деле, все несколько сложнее, чем здесь написано. Ниже, я хочу, в общих
чертах рассказать о принципах работы CommonJS, и об использовании этой модульной
системы в браузере, как более простой альтернативе AMD._


### Введение

[CommonJS][1] — это рабочая группа энтузиастов, которая проектирует,
прототипирует и стандартизирует различные JavaScript API. Благодаря труду
этих ребят появился одноименный стандарт модульной системы, о котором я и
буду рассказывать дальше.

Сейчас CommonJS используется преимущественно в NodeJS — серверном JavaScript.
Но с каждым днем он все ближе подбирается к браузерам. Тогда как модульность —
это и есть один из главных залогов гибкости, CommonJS с помощью простого
интерфейса позволяет достаточно легко создавать устойчивые к изменениям системы,
состоящие из готовых к переиспользованию компонентов. На сегодняшний день,
существует достаточно большое количество утилит, позволяющех использовать
CommonJS-модули в браузере. Первыми в голову приходят [browserify][2], [clinch][3] и
[Component][4].

«Чистый» CommonJS, в сравнивнении с существующими решениями, похож на AMD, но,
в отличии от последнего, менее компромисный. и более простой. Дизайн, основанный
на простоте позволяет за меньшее количество усилий получить практически
аналогичные возможности.

В отличие от Bower, CommonJS позволяет подключать зависимости в переменные,
контролируя глобальный скоп.


## Как работает CommonJS

Объясню устройство CommonJS Не слишком углубляясь в подробности:

Содержимое каждого из модулей оборачивается в замыкания, в которые через
аргументы передаются ссылки на служебные методы и объекты:

```JS
function (require, module) {
  // content 
}
```

-  `require`— этот метод позволяет подключать другие модули по имени или
   по относительному пути к файлу. Пример: `require('./my-awesome-module.js')`,
-  `module.exports` — сюда сохраняется то, что должен вернуть `require` при
   подключении этого модуля. У `module.exports` есть короткий синоним — `exports`.
-  В NodeJS через аргументы замыкания передаются еще и глобальные объекты
   `process`, `global`.


Полученные в результате замыкания сохраняются в специальный словарь, где ключ
равен абсолютному пути к файлу модуля. Таким образом, `require` всегда возвращает
ссылку на единственное замыкание, в котором хранится код модуля вне зависимости
от способа подключения. 

Вот, в общем-то и все устройство.  

### Пример модуля

```JS
'use strict';

var $ = require('jquery');
var counter = 0;

exports.add = function (count) {
  counter += count || 1;
};

exports.get = function () {
  return counter;
}

exports.reset = function () {
  counter = 0;
}
```


Этот пример достаточно наглядно показывает, что в сущности CommonJS-модуль — это
замыкание.


## Сборка

Для сборки с помощью `browserify` достаточно набрать в консоли:

```bash
browserify index.js > bundle.js
```

Browseryfy соберет все используемые модули в один файл, который можно будет
подключить к браузеру как обычный скрипт. 

## Плоские зависимости

Для избежания конфликтов между несколькими зависимостями использующими
различные версии одинаковых библиотек и утилит, таких, как `_`, `grunt`, `async` и
совершенно любой другой модуль, npm использует принцип вложенных зависимостей, 
позволяющий каждому компоненту иметь свои собственные версии нужных модулей.
Дублирование модулей — компромисная плата за простоту управления зависимостями.

Для наглядности, я покажу небольшой фрагмент [списка зависимостей][5], который недавно выложил
[jonathanong][6]:

```
Jonathans-MacBook-Pro:proxy.js jong$ pkgcount --duplicates
options.sortKey name
 
NAME                                    COUNT
abbrev@1.0.5                            25   
accepts@1.0.7                           9    
amdefine@0.1.0                          105  
ansi-regex@0.1.0                        8    
ansi-regex@0.2.1                        16   
ansi-styles@1.0.0                       26   
ansi-styles@1.1.0                       8    
argparse@0.1.15                         34   
asn1@0.1.11                             26   
assert-plus@0.1.2                       26   
ast-types@0.4.8                         17   
async@0.2.10                            60   
async@0.9.0                             60   
await-event@1.0.0                       9    
aws-sign2@0.5.0                         26   
base62@0.1.1                            17   
...
```

Вероятно, это очень большой проект. В проектах, которыми я могу похвастаться,
едва ли наберется с дюжину дублей.

Как бы то ни было, вложенные зависимости не подходят для браузера. Если бы
каждый модуль которому потребовался `jQuery` или `Backbone` устанавливал
бы их в собственных зависимостях, ваш код уже не нужно было бы оптимизировать.

Существует несколько способов решения проблемы.

Можно воспользоваться тем же подходом, на котором основан CommonJS — 
создать замыкание и передать через него все нужные зависимости:

```JS
// omg.js
module.exports = function ($, undefined) {
  $.OMG = function () {
  // I need more magic here!
  console.log
    .bind(console, 'OMMMGGG!!!11one')
    .apply(console, arguments);
  }
};

// index.js
var $ = require('jquery');
var omg = require('omg')($);

omg('You killed Kenny!!!');
```


Некоторые модули, например `Backbone`, позволяют устанавливать
зависимости после инициализации:

```JS
var Backbone = require('Backbone');
var $ = Backbone.$ = require('jquery');
```

Еще одна альтернатива — использовать специальныйменеджерзависимостей
для клиент-сайда, такой как [Component][7]. Я, честно сказать, еще
не попробовал его, так что на этот счет ничего не скажу.


## Поддержка

Часто так случается, что определенный модуль не поддерживает CommonJS. В большинстве
случаев добавить поддержку достаточно тривиально. Вот пример обертки над jQuery-плагином,
позволяющей использовать его с CommonJS и AMD:

```JS
(function (factory) {
  "use strict";
  if (typeof define === 'function' && define.amd) {
    // using AMD
    define(['jquery'], factory);
  //
  } else if (typeof exports !== 'undefined') {
    using CommonJS
    module.exports = factory;
  } else {
    // no AMD/CommonJS; invoke directly
    factory( (typeof(jQuery) != 'undefined') ? jQuery : window.Zepto );
  }
})(function($) {
  "use strict";
    // plugin code
  });
```

Я верю, что разработчики модулей в скором времени начнут уделять больше
внимания поддержке CommonJS и публикации своих проектов в NPM или Component,
ну и мы придем к удобной и функциональной модульной системе, и менеджеру
пакетов.

В конце хочется отметить, что с npm в плане управления клиентскими зависимостями
нужно держать ухо в остро — принцип вложенных зависимостей не приемлем для
браузеров, и, не уделяя этому внимания, вы рискуете подключить 4 версии jQuery,
11 — Backbone и 9 — Underscore. В этом отношении Component, использующий
плоские зависимости, будет гораздо безопаснее, но я, честно говоря, не успел его
еще достаточно опробовать.


[1]: http://www.commonjs.org/
[2]: http://browserify.org/
[3]: https://github.com/Meettya/clinch
[4]: http://component.io/
[5]: https://gist.github.com/jonathanong/2031166ee7e93b909b26
[6]: https://github.com/jonathanong
[7]: https://github.com/component/component
