---

layout: post
title: "Как работает CommonJS"
description: ""
keywords: [""]

---


### И сразу… Дисклеймер

_На самом деле, все несколько сложнее, чем здесь написано. Ниже, я хочу, в общих
чертах рассказать о принципах работы CommonJS, и об использовании этой модульной
системы в браузере, как более простой альтернативе AMD._


### Введение

[CommonJS][1] — это рабочая группа энтузиастов, которая проектирует,
прототипирует и стандартизирует различные JavaScript API. Благодаря труду
этих ребят появился одноименный стандарт модульной системы, о котором я и
буду рассказывать дальше.

Сейчас CommonJS используется преимущественно в NodeJS — серверном JavaScript.
Но с каждым днем он все ближе подбирается к браузерам. Тогда как модульность —
это и есть один из главных залогов гибкости, CommonJS с помощью простого
интерфейса позволяет достаточно легко создавать устойчивые к изменениям системы,
состоящие из готовых к переиспользованию компонентов. На сегодняшний день,
существует достаточно большое количество утилит, позволяющех использовать
CommonJS-модули в браузере. Первыми в голову приходят [browserify][2], [clinch][3] и
[Component][4].

«Чистый» CommonJS, в сравнивнении с существующими решениями, похож на AMD, но,
в отличии от последнего, менее компромисный. и более простой. Дизайн, основанный
на простоте позволяет за меньшее количество усилий получить практически
аналогичные возможности.

В отличие от Bower, CommonJS позволяет подключать зависимости в переменные,
контролируя глобальный скоп.


## Как работает CommonJS

Объясню устройство CommonJS Не слишком углубляясь в подробности:

{% highlight javascript %}
function (require, module) {
  // module code
}
{% endhighlight %}

1. Содержимое каждого из модулей оборачивается в замыкания, которые принимают
   несколько аргументов:
2. `require`— эта функция позволяет подключать другие модули по имени или
   по относительному пути к файлу. Пример: `require('./my-awesome-module.js')`,
3. `module.exports` — это объект или примитив, который получит пользователь,
   подключив модуль через `require`. У `module.exports` есть короткий синоним — `exports`
4. Замыкания кешуруются в специальный хеш, где ключ равен абсолютному пути к файлу
   модуля,
5. при запросе уже закешированного файла возвращается ссылка на существующее замыкание.

Вот, в общем-то и все устройство. В NodeJS через аргументы замыкания передаются
еще и глобальные объекты `process`, `global`. Кроме того, `requre` может подключать
модули из `node_modules` по их назавниям.

### Пример модуля

{% highlight javascript %}
'use strict';

var $ = require('jquery')
  , counter = 0
  ;

exports.add = function (count) {
  counter += count || 1;
};

exports.get = function () {
  return counter;
}

exports.reset = function () {
  counter = 0;
}
{% endhighlight %}


Этот пример достаточно наглядно показывает, что в сущности CommonJS-модуль — это
замыкание.


## Сборка

Для сборки с помощью `browserify` достаточно набрать в консоли:

{% highlight bash %}
browserify index.js > bundle.js
{% endhighlight %}

Browseryfy соберет все используемые модули в один файл, который можно будет
подключить к браузеру как обычный скрипт. Кроме этого, browserify позаботится
о замене некоторых нативных nodejs-модулей, таких как `util` для использования
в браузере.


## Поддержка

Часто так случается, что определенный модуль не поддерживает CommonJS. В большинстве
случаев добавить поддержку достаточно тривиально. Вот пример обертки над jQuery-плагином,
позволяющей использовать его с CommonJS и AMD:

{% highlight javascript %}
(function (factory) {
  "use strict";
  if (typeof define === 'function' && define.amd) {
    // using AMD
    define(['jquery'], factory);
  //
  } else if (typeof exports !== 'undefined') {
    using CommonJS
    module.exports = factory;
  } else {
    // no AMD/CommonJS; invoke directly
    factory( (typeof(jQuery) != 'undefined') ? jQuery : window.Zepto );
  }
})(function($) {
  "use strict";
    // plugin code
  });
{% endhighlight %}

Я верю, что разработчики модулей в скором времени начнут уделять больше
внимания поддержке CommonJS и публикации своих проектов в NPM или Component,
ну и мы придем к удобной и функциональной модульной системе, и менеджеру
пакетов.

В конце хочется отметить, что с npm в плане управления клиентскими зависимостями
нужно держать ухо в остро — принцип вложенных зависимостей не приемлем для
браузеров, и, не уделяя этому внимания, вы рискуете подключить 4 версии jQuery,
11 — Backbone и 9 — Underscore. В этом отношении Component, использующий
плоские зависимости, будет гораздо безопаснее, но я, честно говоря, не успел его
еще достаточно опробовать.


[1]: http://www.commonjs.org/
[2]: http://browserify.org/
[3]: https://github.com/Meettya/clinch
[4]: http://component.io/
